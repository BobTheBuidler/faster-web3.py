def all_in_dict(values, d):
    values :: object
    d :: union[object, dict]
    r0 :: dict
    r1 :: bool
    r2, r3 :: object
    r4 :: dict
    r5 :: i32
    r6 :: bit
    r7, r8 :: bool
    r9 :: bit
    r10 :: bool
L0:
    r0 = CPyDict_FromAny(d)
    if is_error(r0) goto L9 (error at all_in_dict:27) else goto L1
L1:
    d = r0
    r1 = 1
    r2 = PyObject_GetIter(values)
    if is_error(r2) goto L10 (error at all_in_dict:28) else goto L2
L2:
    r3 = PyIter_Next(r2)
    if is_error(r3) goto L11 else goto L3
L3:
    inc_ref d
    r4 = cast(dict, d)
    if is_error(r4) goto L12 (error at all_in_dict:28) else goto L4
L4:
    r5 = PyDict_Contains(r4, r3)
    dec_ref r4
    dec_ref r3
    r6 = r5 >= 0 :: signed
    if not r6 goto L13 (error at all_in_dict:28) else goto L5 :: bool
L5:
    r7 = truncate r5: i32 to builtins.bool
    r8 = r7 ^ 1
    if r8 goto L14 else goto L2 :: bool
L6:
    r1 = 0
    goto L8
L7:
    r9 = CPy_NoErrOccurred()
    if not r9 goto L9 (error at all_in_dict:28) else goto L8 :: bool
L8:
    return r1
L9:
    r10 = <error> :: bool
    return r10
L10:
    dec_ref d
    goto L9
L11:
    dec_ref d
    dec_ref r2
    goto L7
L12:
    dec_ref d
    dec_ref r2
    dec_ref r3
    goto L9
L13:
    dec_ref d
    dec_ref r2
    goto L9
L14:
    dec_ref d
    dec_ref r2
    goto L6

def any_in_dict(values, d):
    values :: object
    d :: union[object, dict]
    r0 :: dict
    r1 :: bool
    r2, r3 :: object
    r4 :: dict
    r5 :: i32
    r6 :: bit
    r7 :: bool
    r8 :: bit
    r9 :: bool
L0:
    r0 = CPyDict_FromAny(d)
    if is_error(r0) goto L9 (error at any_in_dict:43) else goto L1
L1:
    d = r0
    r1 = 0
    r2 = PyObject_GetIter(values)
    if is_error(r2) goto L10 (error at any_in_dict:44) else goto L2
L2:
    r3 = PyIter_Next(r2)
    if is_error(r3) goto L11 else goto L3
L3:
    inc_ref d
    r4 = cast(dict, d)
    if is_error(r4) goto L12 (error at any_in_dict:44) else goto L4
L4:
    r5 = PyDict_Contains(r4, r3)
    dec_ref r4
    dec_ref r3
    r6 = r5 >= 0 :: signed
    if not r6 goto L13 (error at any_in_dict:44) else goto L5 :: bool
L5:
    r7 = truncate r5: i32 to builtins.bool
    if r7 goto L14 else goto L2 :: bool
L6:
    r1 = 1
    goto L8
L7:
    r8 = CPy_NoErrOccurred()
    if not r8 goto L9 (error at any_in_dict:44) else goto L8 :: bool
L8:
    return r1
L9:
    r9 = <error> :: bool
    return r9
L10:
    dec_ref d
    goto L9
L11:
    dec_ref d
    dec_ref r2
    goto L7
L12:
    dec_ref d
    dec_ref r2
    dec_ref r3
    goto L9
L13:
    dec_ref d
    dec_ref r2
    goto L9
L14:
    dec_ref d
    dec_ref r2
    goto L6

def none_in_dict(values, d):
    values :: object
    d :: union[object, dict]
    r0, r1, r2 :: bool
L0:
    r0 = any_in_dict(values, d)
    if is_error(r0) goto L2 (error at none_in_dict:59) else goto L1
L1:
    r1 = r0 ^ 1
    return r1
L2:
    r2 = <error> :: bool
    return r2

def either_set_is_a_subset(set1, set2, percentage):
    set1, set2 :: set
    percentage :: int
    r0 :: float
    r1 :: bit
    r2 :: str
    r3 :: object[2]
    r4 :: object_ptr
    r5, r6 :: object
    r7 :: set
    r8 :: ptr
    r9 :: native_int
    r10 :: short_int
    r11 :: ptr
    r12 :: native_int
    r13 :: short_int
    r14, r15, r16 :: object
    r17 :: float
    r18 :: bit
    r19, r20, r21, r22 :: object
    r23, r24 :: bool
    r25 :: str
    r26 :: object[2]
    r27 :: object_ptr
    r28 :: object
    r29 :: set
    r30 :: ptr
    r31 :: native_int
    r32 :: short_int
    r33 :: ptr
    r34 :: native_int
    r35 :: short_int
    r36, r37, r38 :: object
    r39 :: float
    r40 :: bit
    r41, r42, r43, r44 :: object
    r45, r46 :: bool
L0:
    if is_error(percentage) goto L1 else goto L23
L1:
    percentage = 200
L2:
    r0 = CPyTagged_TrueDivide(percentage, 200)
    dec_ref percentage :: int
    r1 = r0 == -113.0
    if r1 goto L4 else goto L3 :: bool
L3:
    r2 = 'intersection'
    r3 = [set1, set2]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r2, r4, 9223372036854775810, 0)
    if is_error(r5) goto L22 (error at either_set_is_a_subset:82) else goto L5
L4:
    r6 = PyErr_Occurred()
    if not is_error(r6) goto L22 (error at either_set_is_a_subset:79) else goto L3
L5:
    r7 = cast(set, r5)
    if is_error(r7) goto L22 (error at either_set_is_a_subset:82) else goto L6
L6:
    r8 = get_element_ptr r7 used :: PySetObject
    r9 = load_mem r8 :: native_int*
    dec_ref r7
    r10 = r9 << 1
    r11 = get_element_ptr set1 used :: PySetObject
    r12 = load_mem r11 :: native_int*
    r13 = r12 << 1
    r14 = box(short_int, r13)
    r15 = box(float, r0)
    r16 = PyNumber_Multiply(r14, r15)
    dec_ref r14
    dec_ref r15
    if is_error(r16) goto L22 (error at either_set_is_a_subset:82) else goto L7
L7:
    r17 = unbox(float, r16)
    dec_ref r16
    r18 = r17 == -113.0
    if r18 goto L9 else goto L8 :: bool
L8:
    r19 = box(short_int, r10)
    r20 = box(float, r17)
    r21 = PyObject_RichCompare(r19, r20, 5)
    dec_ref r19
    dec_ref r20
    if is_error(r21) goto L22 (error at either_set_is_a_subset:82) else goto L10
L9:
    r22 = PyErr_Occurred()
    if not is_error(r22) goto L22 (error at either_set_is_a_subset:82) else goto L8
L10:
    r23 = unbox(bool, r21)
    dec_ref r21
    if is_error(r23) goto L22 (error at either_set_is_a_subset:82) else goto L11
L11:
    if r23 goto L12 else goto L13 :: bool
L12:
    r24 = r23
    goto L21
L13:
    r25 = 'intersection'
    r26 = [set2, set1]
    r27 = load_address r26
    r28 = PyObject_VectorcallMethod(r25, r27, 9223372036854775810, 0)
    if is_error(r28) goto L22 (error at either_set_is_a_subset:83) else goto L14
L14:
    r29 = cast(set, r28)
    if is_error(r29) goto L22 (error at either_set_is_a_subset:83) else goto L15
L15:
    r30 = get_element_ptr r29 used :: PySetObject
    r31 = load_mem r30 :: native_int*
    dec_ref r29
    r32 = r31 << 1
    r33 = get_element_ptr set2 used :: PySetObject
    r34 = load_mem r33 :: native_int*
    r35 = r34 << 1
    r36 = box(short_int, r35)
    r37 = box(float, r0)
    r38 = PyNumber_Multiply(r36, r37)
    dec_ref r36
    dec_ref r37
    if is_error(r38) goto L22 (error at either_set_is_a_subset:83) else goto L16
L16:
    r39 = unbox(float, r38)
    dec_ref r38
    r40 = r39 == -113.0
    if r40 goto L18 else goto L17 :: bool
L17:
    r41 = box(short_int, r32)
    r42 = box(float, r39)
    r43 = PyObject_RichCompare(r41, r42, 5)
    dec_ref r41
    dec_ref r42
    if is_error(r43) goto L22 (error at either_set_is_a_subset:83) else goto L19
L18:
    r44 = PyErr_Occurred()
    if not is_error(r44) goto L22 (error at either_set_is_a_subset:83) else goto L17
L19:
    r45 = unbox(bool, r43)
    dec_ref r43
    if is_error(r45) goto L22 (error at either_set_is_a_subset:83) else goto L20
L20:
    r24 = r45
L21:
    return r24
L22:
    r46 = <error> :: bool
    return r46
L23:
    inc_ref percentage :: int
    goto L2

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L6 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Iterable', 'Mapping', 'Set', 'Union')
    r6 = 'typing'
    r7 = faster_web3._utils.utility_methods.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L6 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('TxData', 'TxParams')
    r10 = 'faster_web3.types'
    r11 = faster_web3._utils.utility_methods.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L6 (error at <module>:9) else goto L5
L5:
    faster_web3.types = r12 :: module
    dec_ref r12
    return 1
L6:
    r13 = <error> :: None
    return r13

def verify_attr(class_name, key, namespace):
    class_name, key :: str
    namespace :: object
    r0 :: i32
    r1 :: bit
    r2, r3 :: bool
    r4, r5, r6, r7, r8, r9 :: str
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: None
L0:
    r0 = PySequence_Contains(namespace, key)
    r1 = r0 >= 0 :: signed
    if not r1 goto L8 (error at verify_attr:27) else goto L1 :: bool
L1:
    r2 = truncate r0: i32 to builtins.bool
    r3 = r2 ^ 1
    if r3 goto L2 else goto L7 :: bool
L2:
    r4 = 'Property '
    r5 = ' not found on '
    r6 = ' class. `'
    r7 = '.factory` only accepts keyword arguments which are present on the '
    r8 = ' class'
    r9 = CPyStr_Build(9, r4, key, r5, class_name, r6, class_name, r7, class_name, r8)
    if is_error(r9) goto L8 (error at verify_attr:29) else goto L3
L3:
    r10 = faster_web3._utils.datatypes.globals :: static
    r11 = 'Web3AttributeError'
    r12 = CPyDict_GetItem(r10, r11)
    if is_error(r12) goto L9 (error at verify_attr:28) else goto L4
L4:
    r13 = [r9]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L9 (error at verify_attr:28) else goto L5
L5:
    dec_ref r9
    CPy_Raise(r15)
    dec_ref r15
    if not 0 goto L8 (error at verify_attr:28) else goto L6 :: bool
L6:
    unreachable
L7:
    return 1
L8:
    r16 = <error> :: None
    return r16
L9:
    dec_ref r9
    goto L8

def __init___PropertyCheckingFactory_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __init___PropertyCheckingFactory_obj.__call__(__mypyc_self__, cls, name, bases, namespace, kwargs):
    __mypyc_self__ :: faster_web3._utils.datatypes.__init___PropertyCheckingFactory_obj
    cls :: faster_web3._utils.datatypes.PropertyCheckingFactory
    name :: str
    bases :: tuple
    namespace, kwargs :: dict
    r0 :: object
    r1 :: str
    r2 :: object[5]
    r3 :: object_ptr
    r4 :: object
    r5 :: None
L0:
    r0 = load_address PyType_Type
    r1 = '__init__'
    r2 = [r0, cls, name, bases, namespace]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775813, 0)
    if is_error(r4) goto L2 (error at __init__:46) else goto L3
L1:
    return 1
L2:
    r5 = <error> :: None
    return r5
L3:
    dec_ref r4
    goto L1

def __new___PropertyCheckingFactory_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __new___PropertyCheckingFactory_obj.__call__(__mypyc_self__, mcs, name, bases, namespace, normalizers):
    __mypyc_self__ :: faster_web3._utils.datatypes.__new___PropertyCheckingFactory_obj
    mcs :: object
    name :: str
    bases :: tuple[object]
    namespace :: dict
    normalizers :: union[dict, None]
    r0 :: object
    r1 :: list
    r2, r3, r4 :: object
    r5 :: str
    r6 :: object
    r7 :: tuple
    r8 :: i32
    r9, r10 :: bit
    r11, r12 :: object
    r13 :: bool
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: set
    r18 :: list
    r19, r20 :: object
    r21 :: str
    r22 :: object
    r23 :: str
    r24 :: object[1]
    r25 :: object_ptr
    r26 :: object
    r27 :: i32
    r28, r29 :: bit
    r30, r31 :: object
    r32 :: bool
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36 :: set
    r37 :: short_int
    r38 :: native_int
    r39 :: object
    r40 :: tuple[bool, short_int, object]
    r41 :: short_int
    r42 :: bool
    r43 :: object
    r44 :: str
    r45 :: None
    r46, r47 :: bit
    r48 :: object
    r49 :: bit
    r50 :: dict
    r51 :: native_int
    r52 :: short_int
    r53 :: bit
    r54 :: dict
    r55 :: object
    r56 :: bool
    r57 :: object[2]
    r58 :: object_ptr
    r59 :: object
    r60, processed_namespace :: dict
    r61 :: object
    r62 :: str
    r63 :: object
    r64 :: object[5]
    r65 :: object_ptr
    r66 :: object
    r67, r68 :: faster_web3._utils.datatypes.PropertyCheckingFactory
L0:
    if is_error(normalizers) goto L1 else goto L49
L1:
    r0 = box(None, 1)
    inc_ref r0
    normalizers = r0
L2:
    r1 = PyList_New(0)
    if is_error(r1) goto L50 (error at __new__:56) else goto L3
L3:
    inc_ref bases
    r2 = box(tuple[object], bases)
    r3 = PyObject_GetIter(r2)
    dec_ref r2
    if is_error(r3) goto L51 (error at __new__:56) else goto L4
L4:
    r4 = PyIter_Next(r3)
    if is_error(r4) goto L52 else goto L5
L5:
    r5 = '__mro__'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L53 (error at __new__:56) else goto L6
L6:
    r7 = cast(tuple, r6)
    if is_error(r7) goto L53 (error at __new__:56) else goto L7
L7:
    r8 = PyList_Append(r1, r7)
    dec_ref r7
    r9 = r8 >= 0 :: signed
    if not r9 goto L53 (error at __new__:56) else goto L4 :: bool
L8:
    r10 = CPy_NoErrOccurred()
    if not r10 goto L51 (error at __new__:56) else goto L9 :: bool
L9:
    r11 = PyObject_GetIter(r1)
    dec_ref r1
    if is_error(r11) goto L50 (error at __new__:56) else goto L10
L10:
    r12 = faster_web3._utils.datatypes.concat :: static
    if is_error(r12) goto L54 else goto L13
L11:
    r13 = raise NameError('value for final name "concat" was not set')
    if not r13 goto L48 (error at __new__:56) else goto L12 :: bool
L12:
    unreachable
L13:
    r14 = [r11]
    r15 = load_address r14
    r16 = PyObject_Vectorcall(r12, r15, 1, 0)
    if is_error(r16) goto L55 (error at __new__:56) else goto L14
L14:
    dec_ref r11
    r17 = PySet_New(r16)
    dec_ref r16
    if is_error(r17) goto L50 (error at __new__:56) else goto L15
L15:
    r18 = PyList_New(0)
    if is_error(r18) goto L56 (error at __new__:57) else goto L16
L16:
    r19 = PyObject_GetIter(r17)
    dec_ref r17
    if is_error(r19) goto L57 (error at __new__:57) else goto L17
L17:
    r20 = PyIter_Next(r19)
    if is_error(r20) goto L58 else goto L18
L18:
    r21 = '__dict__'
    r22 = CPyObject_GetAttr(r20, r21)
    dec_ref r20
    if is_error(r22) goto L59 (error at __new__:57) else goto L19
L19:
    r23 = 'keys'
    r24 = [r22]
    r25 = load_address r24
    r26 = PyObject_VectorcallMethod(r23, r25, 9223372036854775809, 0)
    if is_error(r26) goto L60 (error at __new__:57) else goto L20
L20:
    dec_ref r22
    r27 = PyList_Append(r18, r26)
    dec_ref r26
    r28 = r27 >= 0 :: signed
    if not r28 goto L59 (error at __new__:57) else goto L17 :: bool
L21:
    r29 = CPy_NoErrOccurred()
    if not r29 goto L57 (error at __new__:57) else goto L22 :: bool
L22:
    r30 = PyObject_GetIter(r18)
    dec_ref r18
    if is_error(r30) goto L50 (error at __new__:57) else goto L23
L23:
    r31 = faster_web3._utils.datatypes.concat :: static
    if is_error(r31) goto L61 else goto L26
L24:
    r32 = raise NameError('value for final name "concat" was not set')
    if not r32 goto L48 (error at __new__:57) else goto L25 :: bool
L25:
    unreachable
L26:
    r33 = [r30]
    r34 = load_address r33
    r35 = PyObject_Vectorcall(r31, r34, 1, 0)
    if is_error(r35) goto L62 (error at __new__:57) else goto L27
L27:
    dec_ref r30
    r36 = PySet_New(r35)
    dec_ref r35
    if is_error(r36) goto L50 (error at __new__:57) else goto L28
L28:
    r37 = 0
    r38 = PyDict_Size(namespace)
    r39 = CPyDict_GetKeysIter(namespace)
    if is_error(r39) goto L63 (error at __new__:59) else goto L29
L29:
    r40 = CPyDict_NextKey(r39, r37)
    r41 = r40[1]
    r37 = r41
    r42 = r40[0]
    if r42 goto L30 else goto L64 :: bool
L30:
    r43 = r40[2]
    dec_ref r40
    r44 = cast(str, r43)
    if is_error(r44) goto L65 (error at __new__:59) else goto L31
L31:
    r45 = verify_attr(name, r44, r36)
    dec_ref r44
    if is_error(r45) goto L65 (error at __new__:60) else goto L32
L32:
    r46 = CPyDict_CheckSize(namespace, r38)
    if not r46 goto L65 (error at __new__:59) else goto L29 :: bool
L33:
    r47 = CPy_NoErrOccurred()
    if not r47 goto L50 (error at __new__:59) else goto L34 :: bool
L34:
    r48 = load_address _Py_NoneStruct
    r49 = normalizers != r48
    if r49 goto L35 else goto L66 :: bool
L35:
    inc_ref normalizers
    r50 = cast(dict, normalizers)
    if is_error(r50) goto L50 (error at __new__:54) else goto L36
L36:
    r51 = PyDict_Size(r50)
    dec_ref r50
    r52 = r51 << 1
    r53 = r52 != 0
    if r53 goto L37 else goto L66 :: bool
L37:
    r54 = cast(dict, normalizers)
    if is_error(r54) goto L48 (error at __new__:64) else goto L38
L38:
    r55 = faster_web3._utils.datatypes.apply_formatters_to_dict :: static
    if is_error(r55) goto L67 else goto L41
L39:
    r56 = raise NameError('value for final name "apply_formatters_to_dict" was not set')
    if not r56 goto L48 (error at __new__:63) else goto L40 :: bool
L40:
    unreachable
L41:
    r57 = [r54, namespace]
    r58 = load_address r57
    r59 = PyObject_Vectorcall(r55, r58, 2, 0)
    if is_error(r59) goto L68 (error at __new__:63) else goto L42
L42:
    dec_ref r54
    r60 = cast(dict, r59)
    if is_error(r60) goto L48 (error at __new__:63) else goto L43
L43:
    processed_namespace = r60
    goto L45
L44:
    inc_ref namespace
    processed_namespace = namespace
L45:
    r61 = load_address PyType_Type
    r62 = '__new__'
    inc_ref bases
    r63 = box(tuple[object], bases)
    r64 = [r61, mcs, name, r63, processed_namespace]
    r65 = load_address r64
    r66 = PyObject_VectorcallMethod(r62, r65, 9223372036854775813, 0)
    if is_error(r66) goto L69 (error at __new__:70) else goto L46
L46:
    dec_ref r63
    dec_ref processed_namespace
    r67 = cast(faster_web3._utils.datatypes.PropertyCheckingFactory, r66)
    if is_error(r67) goto L48 (error at __new__:70) else goto L47
L47:
    return r67
L48:
    r68 = <error> :: faster_web3._utils.datatypes.PropertyCheckingFactory
    return r68
L49:
    inc_ref normalizers
    goto L2
L50:
    dec_ref normalizers
    goto L48
L51:
    dec_ref normalizers
    dec_ref r1
    goto L48
L52:
    dec_ref r3
    goto L8
L53:
    dec_ref normalizers
    dec_ref r1
    dec_ref r3
    goto L48
L54:
    dec_ref normalizers
    dec_ref r11
    goto L11
L55:
    dec_ref normalizers
    dec_ref r11
    goto L48
L56:
    dec_ref normalizers
    dec_ref r17
    goto L48
L57:
    dec_ref normalizers
    dec_ref r18
    goto L48
L58:
    dec_ref r19
    goto L21
L59:
    dec_ref normalizers
    dec_ref r18
    dec_ref r19
    goto L48
L60:
    dec_ref normalizers
    dec_ref r18
    dec_ref r19
    dec_ref r22
    goto L48
L61:
    dec_ref normalizers
    dec_ref r30
    goto L24
L62:
    dec_ref normalizers
    dec_ref r30
    goto L48
L63:
    dec_ref normalizers
    dec_ref r36
    goto L48
L64:
    dec_ref r36
    dec_ref r39
    dec_ref r40
    goto L33
L65:
    dec_ref normalizers
    dec_ref r36
    dec_ref r39
    goto L48
L66:
    dec_ref normalizers
    goto L44
L67:
    dec_ref r54
    goto L39
L68:
    dec_ref r54
    goto L48
L69:
    dec_ref processed_namespace
    dec_ref r63
    goto L48

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9, r10 :: object_ptr
    r11 :: object_ptr[2]
    r12 :: c_ptr
    r13 :: native_int[2]
    r14 :: c_ptr
    r15 :: object
    r16 :: dict
    r17, r18 :: str
    r19 :: bit
    r20 :: object
    r21 :: str
    r22 :: dict
    r23, r24 :: object
    r25 :: str
    r26 :: dict
    r27, r28 :: object
    r29 :: str
    r30 :: object
    r31 :: dict
    r32 :: str
    r33 :: i32
    r34 :: bit
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: dict
    r39 :: str
    r40 :: i32
    r41 :: bit
    r42 :: object
    r43 :: str
    r44 :: object
    r45 :: tuple
    r46, r47 :: object
    r48 :: str
    r49 :: bool
    r50, r51 :: str
    r52 :: object
    r53 :: object[2]
    r54 :: object_ptr
    r55 :: object
    r56, r57, r58, r59 :: dict
    r60 :: faster_web3._utils.datatypes.__init___PropertyCheckingFactory_obj
    r61 :: str
    r62 :: i32
    r63 :: bit
    r64 :: faster_web3._utils.datatypes.__new___PropertyCheckingFactory_obj
    r65 :: object
    r66 :: str
    r67 :: object
    r68 :: object[1]
    r69 :: object_ptr
    r70 :: object
    r71 :: str
    r72 :: i32
    r73 :: bit
    r74, r75 :: str
    r76 :: i32
    r77 :: bit
    r78, r79 :: str
    r80 :: i32
    r81 :: bit
    r82, r83 :: str
    r84 :: i32
    r85 :: bit
    r86 :: object[3]
    r87 :: object_ptr
    r88 :: object
    r89 :: dict
    r90 :: str
    r91, r92 :: object
    r93 :: object[1]
    r94 :: object_ptr
    r95, r96 :: object
    r97 :: object[1]
    r98 :: object_ptr
    r99 :: object
    r100 :: dict
    r101 :: str
    r102 :: i32
    r103 :: bit
    r104 :: object
    r105 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L37 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Collection', 'Dict', 'Final', 'Optional', 'Tuple', 'Type')
    r6 = 'typing'
    r7 = faster_web3._utils.datatypes.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L37 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address faster_eth_utils :: module
    r10 = load_address faster_eth_utils.toolz :: module
    r11 = [r9, r10]
    r12 = load_address r11
    r13 = [11, 12]
    r14 = load_address r13
    r15 = (('faster_eth_utils', 'faster_eth_utils', 'faster_eth_utils'), ('faster_eth_utils.toolz', 'faster_eth_utils', 'faster_eth_utils'))
    r16 = faster_web3._utils.datatypes.globals :: static
    r17 = 'faster_web3/_utils/datatypes.py'
    r18 = '<module>'
    r19 = CPyImport_ImportMany(r15, r12, r16, r17, r18, r14)
    if not r19 goto L37 else goto L5 :: bool
L5:
    r20 = ('mypyc_attr',)
    r21 = 'mypy_extensions'
    r22 = faster_web3._utils.datatypes.globals :: static
    r23 = CPyImport_ImportFromMany(r21, r20, r20, r22)
    if is_error(r23) goto L37 (error at <module>:13) else goto L6
L6:
    mypy_extensions = r23 :: module
    dec_ref r23
    r24 = ('Web3AttributeError',)
    r25 = 'faster_web3.exceptions'
    r26 = faster_web3._utils.datatypes.globals :: static
    r27 = CPyImport_ImportFromMany(r25, r24, r24, r26)
    if is_error(r27) goto L37 (error at <module>:17) else goto L7
L7:
    faster_web3.exceptions = r27 :: module
    dec_ref r27
    r28 = faster_eth_utils :: module
    r29 = 'apply_formatters_to_dict'
    r30 = CPyObject_GetAttr(r28, r29)
    if is_error(r30) goto L37 (error at <module>:22) else goto L8
L8:
    faster_web3._utils.datatypes.apply_formatters_to_dict = r30 :: static
    r31 = faster_web3._utils.datatypes.globals :: static
    r32 = 'apply_formatters_to_dict'
    r33 = CPyDict_SetItem(r31, r32, r30)
    dec_ref r30
    r34 = r33 >= 0 :: signed
    if not r34 goto L37 (error at <module>:22) else goto L9 :: bool
L9:
    r35 = faster_eth_utils.toolz :: module
    r36 = 'concat'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L37 (error at <module>:23) else goto L10
L10:
    faster_web3._utils.datatypes.concat = r37 :: static
    r38 = faster_web3._utils.datatypes.globals :: static
    r39 = 'concat'
    r40 = CPyDict_SetItem(r38, r39, r37)
    dec_ref r37
    r41 = r40 >= 0 :: signed
    if not r41 goto L37 (error at <module>:23) else goto L11 :: bool
L11:
    r42 = builtins :: module
    r43 = 'type'
    r44 = CPyObject_GetAttr(r42, r43)
    if is_error(r44) goto L37 (error at <module>:36) else goto L12
L12:
    r45 = PyTuple_Pack(1, r44)
    dec_ref r44
    if is_error(r45) goto L37 (error at <module>:36) else goto L13
L13:
    r46 = load_address PyType_Type
    r47 = CPy_CalculateMetaclass(r46, r45)
    if is_error(r47) goto L38 (error at <module>:36) else goto L14
L14:
    r48 = '__prepare__'
    r49 = PyObject_HasAttr(r47, r48)
    if r49 goto L15 else goto L19 :: bool
L15:
    r50 = 'PropertyCheckingFactory'
    r51 = '__prepare__'
    r52 = CPyObject_GetAttr(r47, r51)
    if is_error(r52) goto L38 (error at <module>:36) else goto L16
L16:
    r53 = [r50, r45]
    r54 = load_address r53
    r55 = PyObject_Vectorcall(r52, r54, 2, 0)
    dec_ref r52
    if is_error(r55) goto L38 (error at <module>:36) else goto L17
L17:
    r56 = cast(dict, r55)
    if is_error(r56) goto L38 (error at <module>:36) else goto L18
L18:
    r57 = r56
    goto L21
L19:
    r58 = PyDict_New()
    if is_error(r58) goto L38 (error at <module>:36) else goto L20
L20:
    r57 = r58
L21:
    r59 = PyDict_New()
    if is_error(r59) goto L39 (error at <module>:36) else goto L22
L22:
    r60 = __init___PropertyCheckingFactory_obj()
    if is_error(r60) goto L40 (error at <module>:37) else goto L23
L23:
    r61 = '__init__'
    r62 = CPyDict_SetItem(r57, r61, r60)
    dec_ref r60
    r63 = r62 >= 0 :: signed
    if not r63 goto L40 (error at <module>:37) else goto L24 :: bool
L24:
    r64 = __new___PropertyCheckingFactory_obj()
    if is_error(r64) goto L40 (error at <module>:49) else goto L25
L25:
    r65 = builtins :: module
    r66 = 'staticmethod'
    r67 = CPyObject_GetAttr(r65, r66)
    if is_error(r67) goto L41 (error at <module>:49) else goto L26
L26:
    r68 = [r64]
    r69 = load_address r68
    r70 = PyObject_Vectorcall(r67, r69, 1, 0)
    dec_ref r67
    if is_error(r70) goto L41 (error at <module>:49) else goto L27
L27:
    dec_ref r64
    r71 = '__new__'
    r72 = CPyDict_SetItem(r57, r71, r70)
    dec_ref r70
    r73 = r72 >= 0 :: signed
    if not r73 goto L40 (error at <module>:49) else goto L28 :: bool
L28:
    r74 = 'PropertyCheckingFactory'
    r75 = '__annotations__'
    r76 = CPyDict_SetItem(r57, r75, r59)
    dec_ref r59
    r77 = r76 >= 0 :: signed
    if not r77 goto L39 (error at <module>:36) else goto L29 :: bool
L29:
    r78 = 'mypyc filler docstring'
    r79 = '__doc__'
    r80 = CPyDict_SetItem(r57, r79, r78)
    r81 = r80 >= 0 :: signed
    if not r81 goto L39 (error at <module>:36) else goto L30 :: bool
L30:
    r82 = 'faster_web3._utils.datatypes'
    r83 = '__module__'
    r84 = CPyDict_SetItem(r57, r83, r82)
    r85 = r84 >= 0 :: signed
    if not r85 goto L39 (error at <module>:36) else goto L31 :: bool
L31:
    r86 = [r74, r45, r57]
    r87 = load_address r86
    r88 = PyObject_Vectorcall(r47, r87, 3, 0)
    if is_error(r88) goto L39 (error at <module>:36) else goto L32
L32:
    dec_ref r57
    dec_ref r45
    r89 = faster_web3._utils.datatypes.globals :: static
    r90 = 'mypyc_attr'
    r91 = CPyDict_GetItem(r89, r90)
    if is_error(r91) goto L42 (error at <module>:35) else goto L33
L33:
    r92 = box(bool, 0)
    r93 = [r92]
    r94 = load_address r93
    r95 = ('native_class',)
    r96 = PyObject_Vectorcall(r91, r94, 0, r95)
    dec_ref r91
    if is_error(r96) goto L42 (error at <module>:35) else goto L34
L34:
    r97 = [r88]
    r98 = load_address r97
    r99 = PyObject_Vectorcall(r96, r98, 1, 0)
    dec_ref r96
    if is_error(r99) goto L42 (error at <module>:36) else goto L35
L35:
    dec_ref r88
    faster_web3._utils.datatypes.PropertyCheckingFactory = r99 :: type
    r100 = faster_web3._utils.datatypes.globals :: static
    r101 = 'PropertyCheckingFactory'
    r102 = PyDict_SetItem(r100, r101, r99)
    dec_ref r99
    r103 = r102 >= 0 :: signed
    if not r103 goto L37 (error at <module>:36) else goto L36 :: bool
L36:
    r104 = faster_web3._utils.datatypes.PropertyCheckingFactory :: type
    return 1
L37:
    r105 = <error> :: None
    return r105
L38:
    dec_ref r45
    goto L37
L39:
    dec_ref r45
    dec_ref r57
    goto L37
L40:
    dec_ref r45
    dec_ref r57
    dec_ref r59
    goto L37
L41:
    dec_ref r45
    dec_ref r57
    dec_ref r59
    dec_ref r64
    goto L37
L42:
    dec_ref r88
    goto L37

def percentile(values, percentile):
    values :: object
    percentile :: float
    r0 :: i32
    r1 :: bit
    r2 :: bool
    r3, r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: dict
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23, r24 :: bit
    r25 :: str
    r26 :: dict
    r27 :: str
    r28 :: object
    r29 :: object[1]
    r30 :: object_ptr
    r31 :: object
    r32 :: list
    r33 :: int
    r34 :: float
    r35 :: bit
    r36, r37, r38 :: float
    r39 :: bit
    r40, r41 :: object
    r42 :: int
    r43 :: float
    r44 :: bit
    r45 :: object
    r46, r47 :: float
    r48, r49, r50, r51 :: bit
    r52, r53, fractional :: float
    r54 :: bit
    r55 :: int
    r56 :: object
    r57 :: int
    r58 :: float
    r59 :: bit
    r60 :: object
    r61 :: float
    r62 :: int
    r63 :: object
    r64, r65 :: int
    r66 :: object
    r67, r68 :: int
    r69 :: float
    r70 :: bit
    r71, r72 :: float
    r73 :: bit
    r74 :: object
    r75 :: float
    r76 :: object
    r77 :: float
L0:
    r0 = PyObject_IsTrue(values)
    r1 = r0 >= 0 :: signed
    if not r1 goto L47 (error at percentile:11) else goto L1 :: bool
L1:
    r2 = truncate r0: i32 to builtins.bool
    if r2 goto L10 else goto L2 :: bool
L2:
    r3 = ''
    r4 = 'Expected a sequence of at least 1 integers, got '
    r5 = '{!r:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, values, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L47 (error at percentile:15) else goto L3
L3:
    r11 = cast(str, r10)
    if is_error(r11) goto L47 (error at percentile:15) else goto L4
L4:
    r12 = PyList_New(2)
    if is_error(r12) goto L48 (error at percentile:15) else goto L5
L5:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    inc_ref r4
    set_mem r14, r4 :: builtins.object*
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r3, r12)
    dec_ref r12
    if is_error(r16) goto L47 (error at percentile:15) else goto L6
L6:
    r17 = faster_web3._utils.math.globals :: static
    r18 = 'InsufficientData'
    r19 = CPyDict_GetItem(r17, r18)
    if is_error(r19) goto L49 (error at percentile:14) else goto L7
L7:
    r20 = [r16]
    r21 = load_address r20
    r22 = PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L49 (error at percentile:14) else goto L8
L8:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L47 (error at percentile:14) else goto L9 :: bool
L9:
    unreachable
L10:
    r23 = percentile < 0.0
    if r23 goto L12 else goto L11 :: bool
L11:
    r24 = percentile > 100.0
    if r24 goto L12 else goto L16 :: bool
L12:
    r25 = 'percentile must be in the range [0, 100]'
    r26 = faster_web3._utils.math.globals :: static
    r27 = 'Web3ValueError'
    r28 = CPyDict_GetItem(r26, r27)
    if is_error(r28) goto L47 (error at percentile:18) else goto L13
L13:
    r29 = [r25]
    r30 = load_address r29
    r31 = PyObject_Vectorcall(r28, r30, 1, 0)
    dec_ref r28
    if is_error(r31) goto L47 (error at percentile:18) else goto L14
L14:
    CPy_Raise(r31)
    dec_ref r31
    if not 0 goto L47 (error at percentile:18) else goto L15 :: bool
L15:
    unreachable
L16:
    r32 = CPySequence_Sort(values)
    if is_error(r32) goto L47 (error at percentile:20) else goto L17
L17:
    r33 = CPyObject_Size(values)
    if is_error(r33) goto L50 (error at percentile:22) else goto L18
L18:
    r34 = CPyFloat_FromTagged(r33)
    dec_ref r33 :: int
    r35 = r34 == -113.0
    if r35 goto L20 else goto L19 :: bool
L19:
    r36 = r34 * percentile
    r37 = r36 / 100.0
    r38 = r37 - 1.0
    r39 = r38 < 0.0
    if r39 goto L21 else goto L26 :: bool
L20:
    r40 = PyErr_Occurred()
    if not is_error(r40) goto L50 (error at percentile:22) else goto L19
L21:
    r41 = CPyList_GetItemShort(r32, 0)
    dec_ref r32
    if is_error(r41) goto L47 (error at percentile:24) else goto L22
L22:
    r42 = unbox(int, r41)
    dec_ref r41
    if is_error(r42) goto L47 (error at percentile:24) else goto L23
L23:
    r43 = CPyFloat_FromTagged(r42)
    dec_ref r42 :: int
    r44 = r43 == -113.0
    if r44 goto L25 else goto L24 :: bool
L24:
    return r43
L25:
    r45 = PyErr_Occurred()
    if not is_error(r45) goto L47 (error at percentile:24) else goto L24
L26:
    r46 = r38 % 1.0
    r47 = r46
    r48 = r47 == 0.0
    if r48 goto L29 else goto L27 :: bool
L27:
    r49 = r38 < 0.0
    r50 = 1.0 < 0.0
    r51 = r49 == r50
    if r51 goto L30 else goto L28 :: bool
L28:
    r52 = r47 + 1.0
    r47 = r52
    goto L30
L29:
    r53 = copysign(0.0, 1.0)
    r47 = r53
L30:
    fractional = r47
    r54 = fractional == 0.0
    if r54 goto L31 else goto L37 :: bool
L31:
    r55 = CPyTagged_FromFloat(r38)
    if is_error(r55) goto L50 (error at percentile:28) else goto L32
L32:
    r56 = CPyList_GetItem(r32, r55)
    dec_ref r32
    dec_ref r55 :: int
    if is_error(r56) goto L47 (error at percentile:28) else goto L33
L33:
    r57 = unbox(int, r56)
    dec_ref r56
    if is_error(r57) goto L47 (error at percentile:28) else goto L34
L34:
    r58 = CPyFloat_FromTagged(r57)
    dec_ref r57 :: int
    r59 = r58 == -113.0
    if r59 goto L36 else goto L35 :: bool
L35:
    return r58
L36:
    r60 = PyErr_Occurred()
    if not is_error(r60) goto L47 (error at percentile:28) else goto L35
L37:
    r61 = r38 - fractional
    r62 = CPyTagged_FromFloat(r61)
    if is_error(r62) goto L50 (error at percentile:30) else goto L38
L38:
    r63 = CPyList_GetItem(r32, r62)
    if is_error(r63) goto L51 (error at percentile:31) else goto L39
L39:
    r64 = unbox(int, r63)
    dec_ref r63
    if is_error(r64) goto L51 (error at percentile:31) else goto L40
L40:
    r65 = CPyTagged_Add(r62, 2)
    dec_ref r62 :: int
    r66 = CPyList_GetItem(r32, r65)
    dec_ref r32
    dec_ref r65 :: int
    if is_error(r66) goto L52 (error at percentile:32) else goto L41
L41:
    r67 = unbox(int, r66)
    dec_ref r66
    if is_error(r67) goto L52 (error at percentile:32) else goto L42
L42:
    r68 = CPyTagged_Subtract(r67, r64)
    dec_ref r67 :: int
    r69 = CPyFloat_FromTagged(r68)
    dec_ref r68 :: int
    r70 = r69 == -113.0
    if r70 goto L44 else goto L43 :: bool
L43:
    r71 = fractional * r69
    r72 = CPyFloat_FromTagged(r64)
    dec_ref r64 :: int
    r73 = r72 == -113.0
    if r73 goto L46 else goto L45 :: bool
L44:
    r74 = PyErr_Occurred()
    if not is_error(r74) goto L52 (error at percentile:33) else goto L43
L45:
    r75 = r72 + r71
    return r75
L46:
    r76 = PyErr_Occurred()
    if not is_error(r76) goto L47 (error at percentile:33) else goto L45
L47:
    r77 = <error> :: float
    return r77
L48:
    dec_ref r11
    goto L47
L49:
    dec_ref r16
    goto L47
L50:
    dec_ref r32
    goto L47
L51:
    dec_ref r32
    dec_ref r62 :: int
    goto L47
L52:
    dec_ref r64 :: int
    goto L47

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L6 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Sequence',)
    r6 = 'typing'
    r7 = faster_web3._utils.math.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L6 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('InsufficientData', 'Web3ValueError')
    r10 = 'faster_web3.exceptions'
    r11 = faster_web3._utils.math.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L6 (error at <module>:5) else goto L5
L5:
    faster_web3.exceptions = r12 :: module
    dec_ref r12
    return 1
L6:
    r13 = <error> :: None
    return r13

def to_hex_if_bytes(val):
    val :: union[str, bytes, object]
    r0 :: bit
    r1, r2 :: str
    r3 :: i32
    r4 :: bool
    r5, r6, r7, r8, r9, r10 :: str
    r11 :: object[3]
    r12 :: object_ptr
    r13 :: object
    r14 :: str
    r15 :: list
    r16, r17, r18 :: ptr
    r19 :: str
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: str
    r27 :: object
    r28 :: bool
    r29 :: object[1]
    r30 :: object_ptr
    r31, r32 :: object
    r33 :: str
    r34, r35 :: object
    r36 :: str
    r37 :: object
    r38 :: tuple[object, object]
    r39 :: object
    r40 :: i32
    r41 :: bit
    r42 :: bool
    r43 :: object
    r44 :: bool
    r45 :: object[1]
    r46 :: object_ptr
    r47 :: object
    r48, r49 :: str
    r50 :: object
    r51 :: bool
    r52 :: object[1]
    r53 :: object_ptr
    r54, r55 :: object
    r56, r57 :: str
L0:
    r0 = PyUnicode_Check(val)
    if r0 goto L1 else goto L19 :: bool
L1:
    inc_ref val
    r1 = cast(str, val)
    if is_error(r1) goto L35 (error at to_hex_if_bytes:26) else goto L2
L2:
    r2 = '0x'
    r3 = CPyStr_Startswith(r1, r2)
    dec_ref r1
    r4 = truncate r3: i32 to builtins.bool
    if r4 goto L12 else goto L3 :: bool
L3:
    r5 = ''
    r6 = 'Expected a hex string. Got: '
    r7 = '{!r:{}}'
    inc_ref val
    r8 = cast(str, val)
    if is_error(r8) goto L35 (error at to_hex_if_bytes:27) else goto L4
L4:
    r9 = ''
    r10 = 'format'
    r11 = [r7, r8, r9]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775811, 0)
    if is_error(r13) goto L36 (error at to_hex_if_bytes:27) else goto L5
L5:
    dec_ref r8
    r14 = cast(str, r13)
    if is_error(r14) goto L35 (error at to_hex_if_bytes:27) else goto L6
L6:
    r15 = PyList_New(2)
    if is_error(r15) goto L37 (error at to_hex_if_bytes:27) else goto L7
L7:
    r16 = get_element_ptr r15 ob_item :: PyListObject
    r17 = load_mem r16 :: ptr*
    inc_ref r6
    set_mem r17, r6 :: builtins.object*
    r18 = r17 + 8
    set_mem r18, r14 :: builtins.object*
    r19 = PyUnicode_Join(r5, r15)
    dec_ref r15
    if is_error(r19) goto L35 (error at to_hex_if_bytes:27) else goto L8
L8:
    r20 = faster_web3._utils.type_conversion.globals :: static
    r21 = 'Web3ValueError'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L38 (error at to_hex_if_bytes:27) else goto L9
L9:
    r23 = [r19]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L38 (error at to_hex_if_bytes:27) else goto L10
L10:
    dec_ref r19
    CPy_Raise(r25)
    dec_ref r25
    if not 0 goto L35 (error at to_hex_if_bytes:27) else goto L11 :: bool
L11:
    unreachable
L12:
    inc_ref val
    r26 = cast(str, val)
    if is_error(r26) goto L35 (error at to_hex_if_bytes:28) else goto L13
L13:
    r27 = faster_web3._utils.type_conversion.to_hex :: static
    if is_error(r27) goto L39 else goto L16
L14:
    r28 = raise NameError('value for final name "to_hex" was not set')
    if not r28 goto L35 (error at to_hex_if_bytes:28) else goto L15 :: bool
L15:
    unreachable
L16:
    r29 = [r26]
    r30 = load_address r29
    r31 = ('hexstr',)
    r32 = PyObject_Vectorcall(r27, r30, 0, r31)
    if is_error(r32) goto L40 (error at to_hex_if_bytes:28) else goto L17
L17:
    dec_ref r26
    r33 = cast(str, r32)
    if is_error(r33) goto L35 (error at to_hex_if_bytes:28) else goto L18
L18:
    return r33
L19:
    r34 = load_address PyBytes_Type
    r35 = builtins :: module
    r36 = 'bytearray'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L35 (error at to_hex_if_bytes:30) else goto L20
L20:
    inc_ref r34
    r38 = (r34, r37)
    r39 = box(tuple[object, object], r38)
    r40 = PyObject_IsInstance(val, r39)
    dec_ref r39
    r41 = r40 >= 0 :: signed
    if not r41 goto L35 (error at to_hex_if_bytes:30) else goto L21 :: bool
L21:
    r42 = truncate r40: i32 to builtins.bool
    if r42 goto L22 else goto L28 :: bool
L22:
    r43 = faster_web3._utils.type_conversion.to_hex :: static
    if is_error(r43) goto L23 else goto L25
L23:
    r44 = raise NameError('value for final name "to_hex" was not set')
    if not r44 goto L35 (error at to_hex_if_bytes:30) else goto L24 :: bool
L24:
    unreachable
L25:
    r45 = [val]
    r46 = load_address r45
    r47 = PyObject_Vectorcall(r43, r46, 1, 0)
    if is_error(r47) goto L35 (error at to_hex_if_bytes:30) else goto L26
L26:
    r48 = cast(str, r47)
    if is_error(r48) goto L35 (error at to_hex_if_bytes:30) else goto L27
L27:
    r49 = r48
    goto L34
L28:
    r50 = faster_web3._utils.type_conversion.to_hex :: static
    if is_error(r50) goto L29 else goto L31
L29:
    r51 = raise NameError('value for final name "to_hex" was not set')
    if not r51 goto L35 (error at to_hex_if_bytes:30) else goto L30 :: bool
L30:
    unreachable
L31:
    r52 = [val]
    r53 = load_address r52
    r54 = ('hexstr',)
    r55 = PyObject_Vectorcall(r50, r53, 0, r54)
    if is_error(r55) goto L35 (error at to_hex_if_bytes:30) else goto L32
L32:
    r56 = cast(str, r55)
    if is_error(r56) goto L35 (error at to_hex_if_bytes:30) else goto L33
L33:
    r49 = r56
L34:
    return r49
L35:
    r57 = <error> :: str
    return r57
L36:
    dec_ref r8
    goto L35
L37:
    dec_ref r14
    goto L35
L38:
    dec_ref r19
    goto L35
L39:
    dec_ref r26
    goto L14
L40:
    dec_ref r26
    goto L35

def to_bytes_if_hex(val):
    val :: union[str, bytes, object]
    r0 :: bit
    r1 :: str
    r2 :: object
    r3 :: bool
    r4 :: object[1]
    r5 :: object_ptr
    r6, r7 :: object
    r8 :: bytes
    r9 :: union[bytes, object]
    r10, r11 :: bytes
L0:
    r0 = PyUnicode_Check(val)
    if r0 goto L1 else goto L8 :: bool
L1:
    inc_ref val
    r1 = cast(str, val)
    if is_error(r1) goto L11 (error at to_bytes_if_hex:38) else goto L2
L2:
    r2 = faster_web3._utils.type_conversion.to_bytes :: static
    if is_error(r2) goto L12 else goto L5
L3:
    r3 = raise NameError('value for final name "to_bytes" was not set')
    if not r3 goto L11 (error at to_bytes_if_hex:38) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = [r1]
    r5 = load_address r4
    r6 = ('hexstr',)
    r7 = PyObject_Vectorcall(r2, r5, 0, r6)
    if is_error(r7) goto L13 (error at to_bytes_if_hex:38) else goto L6
L6:
    dec_ref r1
    r8 = cast(bytes, r7)
    if is_error(r8) goto L11 (error at to_bytes_if_hex:38) else goto L7
L7:
    r9 = r8
    goto L9
L8:
    inc_ref val
    r9 = val
L9:
    r10 = cast(bytes, r9)
    if is_error(r10) goto L11 (error at to_bytes_if_hex:38) else goto L10
L10:
    return r10
L11:
    r11 = <error> :: bytes
    return r11
L12:
    dec_ref r1
    goto L3
L13:
    dec_ref r1
    goto L11

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: object_ptr
    r10 :: object_ptr[1]
    r11 :: c_ptr
    r12 :: native_int[1]
    r13 :: c_ptr
    r14 :: object
    r15 :: dict
    r16, r17 :: str
    r18 :: bit
    r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: object
    r30 :: dict
    r31 :: str
    r32 :: i32
    r33 :: bit
    r34 :: object
    r35 :: str
    r36 :: object
    r37 :: dict
    r38 :: str
    r39 :: i32
    r40 :: bit
    r41 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L12 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final', 'Union')
    r6 = 'typing'
    r7 = faster_web3._utils.type_conversion.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L12 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address faster_eth_utils :: module
    r10 = [r9]
    r11 = load_address r10
    r12 = [6]
    r13 = load_address r12
    r14 = (('faster_eth_utils', 'faster_eth_utils', 'faster_eth_utils'),)
    r15 = faster_web3._utils.type_conversion.globals :: static
    r16 = 'faster_web3/_utils/type_conversion.py'
    r17 = '<module>'
    r18 = CPyImport_ImportMany(r14, r11, r15, r16, r17, r13)
    if not r18 goto L12 else goto L5 :: bool
L5:
    r19 = ('HexStr',)
    r20 = 'eth_typing'
    r21 = faster_web3._utils.type_conversion.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L12 (error at <module>:7) else goto L6
L6:
    eth_typing = r22 :: module
    dec_ref r22
    r23 = ('Web3ValueError',)
    r24 = 'faster_web3.exceptions'
    r25 = faster_web3._utils.type_conversion.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L12 (error at <module>:11) else goto L7
L7:
    faster_web3.exceptions = r26 :: module
    dec_ref r26
    r27 = faster_eth_utils :: module
    r28 = 'to_bytes'
    r29 = CPyObject_GetAttr(r27, r28)
    if is_error(r29) goto L12 (error at <module>:16) else goto L8
L8:
    faster_web3._utils.type_conversion.to_bytes = r29 :: static
    r30 = faster_web3._utils.type_conversion.globals :: static
    r31 = 'to_bytes'
    r32 = CPyDict_SetItem(r30, r31, r29)
    dec_ref r29
    r33 = r32 >= 0 :: signed
    if not r33 goto L12 (error at <module>:16) else goto L9 :: bool
L9:
    r34 = faster_eth_utils :: module
    r35 = 'to_hex'
    r36 = CPyObject_GetAttr(r34, r35)
    if is_error(r36) goto L12 (error at <module>:17) else goto L10
L10:
    faster_web3._utils.type_conversion.to_hex = r36 :: static
    r37 = faster_web3._utils.type_conversion.globals :: static
    r38 = 'to_hex'
    r39 = CPyDict_SetItem(r37, r38, r36)
    dec_ref r36
    r40 = r39 >= 0 :: signed
    if not r40 goto L12 (error at <module>:17) else goto L11 :: bool
L11:
    return 1
L12:
    r41 = <error> :: None
    return r41

def construct_user_agent(module, class_name):
    module, class_name :: str
    r0, r1 :: object
    r2 :: str
    r3 :: dict
    r4 :: object
    r5 :: str
    r6 :: dict
    r7 :: str
    r8 :: object
    r9, r10, r11, r12, r13 :: str
L0:
    r0 = ('__version__',)
    r1 = ('web3_version',)
    r2 = 'faster_web3'
    r3 = faster_web3._utils.http.globals :: static
    r4 = CPyImport_ImportFromMany(r2, r0, r1, r3)
    if is_error(r4) goto L5 (error at construct_user_agent:11) else goto L1
L1:
    faster_web3 = r4 :: module
    dec_ref r4
    r5 = 'faster_web3.py/'
    r6 = faster_web3._utils.http.globals :: static
    r7 = 'web3_version'
    r8 = CPyDict_GetItem(r6, r7)
    if is_error(r8) goto L5 (error at construct_user_agent:15) else goto L2
L2:
    r9 = cast(str, r8)
    if is_error(r9) goto L5 (error at construct_user_agent:15) else goto L3
L3:
    r10 = '/'
    r11 = '.'
    r12 = CPyStr_Build(6, r5, r9, r10, module, r11, class_name)
    dec_ref r9
    if is_error(r12) goto L5 (error at construct_user_agent:15) else goto L4
L4:
    return r12
L5:
    r13 = <error> :: str
    return r13

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: dict
    r10 :: str
    r11 :: object
    r12 :: i32
    r13 :: bit
    r14 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L6 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = faster_web3._utils.http.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L6 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = faster_web3._utils.http.globals :: static
    r10 = 'DEFAULT_HTTP_TIMEOUT'
    r11 = box(float, 30.0)
    r12 = CPyDict_SetItem(r9, r10, r11)
    dec_ref r11
    r13 = r12 >= 0 :: signed
    if not r13 goto L6 (error at <module>:4) else goto L5 :: bool
L5:
    return 1
L6:
    r14 = <error> :: None
    return r14
